## 内存和变量
### 内存
1. 内存是由按顺序编号的一系列存储单元组成的，在内存中，每个存储单元都由唯一的地址，通过地址可以方便地在内存单元中存储信息。
2. 在计算机中，一切信息都是以二进制数据的形式体现的，每个内存单元的容量是1B，即8bit（8个0、1二进制位）。
3. 一个程序载入内存，代码数据都有地址，修改数据 
而函数就是代码，变量就是数据   

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    printf("%x\n", main); //打印main函数的首地址
		}
4.32位的计算机最多的内存容量是4G

# 指针和变量
1. 变量名就是对内存一段空间里面数据的抽象
2. 指针变量存放的就是变量的地址。指针变量可以指向任何的一个变量。32位系统，指针变量大小为4个字节，64位为8字节。
3. 指针是个量，对应着一块内存区域，二，指针存储的信息是某个内存单元的地址
4. 指针变量和原变量指向同一块内存区。所以对指针变量和原变量的操作是等价的。

## 指针的基本使用

### 定义
1. 在声明一个指针后，编译器并不会自动完成其初始化，此时，指针的值是不确定的，也就是说，该指针指向那块内存单元是完全随机的。

	如果在指针变量声明之初确实不知道该将此指针指向何处，最简单的方式是将其置“0”，C语言中提供了关键字NULL

		类型名 *变量名 = NULL; //声明指针的形式，加*号

### 基本使用
1. 求地址  

		int num;
		&num //&变量名，求变量的内存地址
2. 间接访问运算符 

		int num  = 10;
		int *p = &num;
		printf("%d\n", *p); // *p访问指针变量所有指向的变量，根据地址取出内容

		num 和 *(&num) 是等价的
		num 就是直接访问
		*p 就是间接访问
3. 打印地址  
	%x:  按照十六进制打印，无意义的0就不打印   
	%p:  显示地址的位数，32位，8个十六进制，2^4=16,32位 显示地址的位数，64位，16个十六进制位，64个二进制位

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int i = 10;
		    int *p = &i;
		    printf("%x, %p\n", p, p);
		}
4. scanf初始化

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a, b;
		    scanf("%d, %d",&a, &b); //函数有副本机制。要传地址才能改变变量的值
		    printf("a= %d, b = %d", a, b);
		}

### 二级指针，指向指针的指针
1. 指针变量也有地址，变量要向指向指针，可以使用二级指针。 

		int **p; //定义一个二级指针。
2. 函数形式参数，除了数组以外，传递的任何数据，变量，都会新建一个变量接收传入的变量的值。  
	如果要在函数修改变量的值，要传递指针（变量地址）;  
	如果要在函数中修改指针的值，要传递指针的指针(指针的地址) 

		#include <stdio.h>
		#include <stdlib.h>
		
		int a = 10, b = 20;
		void change(int **p)
		{
		    *p = &b;
		}
		void main()
		{
		    int *p = &a;
		    printf("before = %d\n", *p); //a的值
		    change(&p);
		    printf("after = %d\n", *p); //b的值
		}

### 指针类型和指针所指向类型
1. 指针类型，是指针声明指针变量时位于变量名前的“类型*”
2. 指针所指向的类型，指的是为指针初始化或赋值的变量类型
3. 实际上指针可以保存任何变量类型的地址。但是，指针实际是保存的变量受地址，指针的类型决定读取变量的读取的字节数。所以不是同一类型的指针，不可以任意赋值，不然会产生垃圾数据  

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a = 1000;
		    char *p = (char *)&a; //强制指向一个char
		
		    printf("%d\n", *p); // 指针为一个char类型，所以只会读取一个字节
		}

### 指针变量的值
1. 指针存储的是地址，地址是首地址，从哪里开始，从哪里结束，由指针类型决定。
类型决定长度，决定如何解析
2. 指针四要素   

		指针的值
		指针的类型
		指针指向类型
		指针指向的值
3. 如果一个指针没为初始化，就是一个野指针。如果不明确指针指向，初始为一个空指针


### 指针的运算
1. 指针可以进行一些运算，但并非所有的运算都是合法的，指针的运算主要局限在加减算术和其他一些为数不多的特殊运算
2. 加法，向后移动指针，移动 n * sizeof(指针类型)。如果为int表示移动4个字节

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a = 10;
		    int *p1 = &a;
		    int *p2 = p1 + 1;
		    printf("%d\n", (int)p2 - (int)p1); //相差4
		}
3. 减法。和加法一样，同的是向前移动指针
4. 指针加减法，在一块内存区内(数组)才有意义。其它运算都是没有意义的。   
5. 在数组中数组名被解析为首地址。 

	 	a[i]  和 *（a+i）是 等价的
 		&a[i] 和 a+i  是等价的
6. 指针遍历数组   

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a[5] = {1, 2, 3, 4, 5};
		    int *p = a; //数组名不用&运算符，因为会自动转换
		    for (int i = 0; i < 5 ; ++i) {
		        printf("*(a + %d) = %d\n", i, *(a + i));
		    }
		}
7.指针的比较是没有意义的。指针是否相等，可以判断是否指向同一地址

### 元素指针和数组指针
1. 指向元素的指针

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a[5] = {1, 2, 3, 4, 5};
		    int *p = a; //p是一个元素指针。指向每一个元素
		    printf("%d\n", *p);
		    int *p1 = &a[0]; //也是一个元素指针
		    printf("%d\n", *p1);
		}
2. 指向数组的指针

	类型 (*p)[] 定义一个数组指针，'[]'可以有多个。这个指针指向一个数组，每次移动指针的字节数为 元素个数组 * 指针类型

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a[5] = {1, 2, 3, 4, 5};
		    int *p = a; //p是一个元素指针。指向每一个元素
		    int (*p1)[5] = &a; //指向有5个元素的数组。&a求数组的地址。a和&a值一样，但是指针类型不一样
		
		    printf("p1=%d, *p1=%d\n", sizeof(p1), sizeof(*p1)); //*p1 = 20
		
		    /**
		     * *p1 指向数组的第一个元素。**p1取于第一个元素
		     * 可能理解为指向数组的指针其实是一个二级指针
		     */
		    printf("**p1 = %d, p1[0][0] = %d\n", **p1, p1[0][0]);
		}
3. 二维数组指针
		
		#include <stdio.h>
		#include <stdlib.h>
		
		void size(int *a[])
		{
		    printf("%d\n", sizeof(a) / sizeof(int));
		}
		void main()
		{
		    /**
		     * 在二维数据中
		     * a是一个行指针，指向有3个元素的一维数组
		     * &a是数组指针指向，9个元素的二维数组
		     * *a 指向一个int类型的数据
		     */
		    int a[3][3] = {
		            {1, 2, 3},
		            {4, 5, 6},
		            {7, 8, 9}
		    };
		
		    //得到数据大小
		    printf("a = %d, *(&a) = %d\n", sizeof(a), sizeof(*(&a)));
		
		    //打印3个行地址
		    printf("a0 =  %p, a1 = %p, a2 = %p\n", a, a + 1 , a + 2);
		    printf("a[0] =  %p, a[1] = %p, a[2] = %p\n", a[0], a[1] , a[2]);
		
		    //a[1][1]  ==  *(*(a + 1) + 1)
		    printf("a[1][1] = %d,  *(*(a + 1) + 1 = %d\n", a[1][1], *(*(a + 1) + 1));
		
		    //指针输出二维数组
		    int (*p)[3] = a;
		    printf("p[1][1] = %d, *(*(p + 2) + 1) = %d\n", p[2][1], *(*(p + 2) + 1));
		
		    //指针遍历二维数据
		    for (int i = 0; i < 3; ++i) {
		        for (int j = 0; j < 3 ; ++j) {
		            printf("a[%d][%d] =  %d\n", i, j, *(*(a + i) + j));
		        }
		    }
		}

### 数组做为函数参数
1. 一维数组做为参数，传递的是元素指针。也是就是第一个元素的首地址。  

		#include <stdio.h>
		#include <stdlib.h>
		
		void f1(int a[]) // int a[] == int *a ,都是表示声明为一个指针
		{
		    printf("f1 = %d\n", *a);
		}
		
		void f2(int *p)
		{
		    printf("f2 = %d\n", *p);
		}
		void main()
		{
		    int a[3] = {1, 2, 3};
		    /**
		     * 做为参数，传递的是指针。数据没有副本机制，只能传递指针
		     * 数组只要一成为参数，就会退化会指针
		     */
		    f1(a);
		    f2(a);
		}
2. 二维数组做为参数，传递的是行指针。  
		
		#include <stdio.h>
		#include <stdlib.h>

		#include <stdio.h>
		#include <stdlib.h>
		
		void f1(int (*p)[2]) // []里面的值不能少，他表示的指针的类型，移动大小
		{
		    printf("f1 = %d\n", p[1][1]);
		}
		
		void main() {
		    int a[2][2] = {1, 2, 3, 4};
		    f1(a); //传送了行指针
		}

### 函数指针
1. 如果在程序中定义了一个函数，在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始地址，称为这个函数的指针。
2. 可以定义一个指向函数的指针变量，用来存放某一函数的起始地址，这就意味着此指针变量指向该函数
3. 定义  

		返回值类型 (*p)(参数类型，...)
		int (*p)(int, int);
4. 使用  

		#include <stdio.h>
		#include <stdlib.h>
		
		void f1(char *str)
		{
		    printf("%s\n", str);
		}
		
		void main()
		{
		    /**
		     * 函数名就函数的首地址。可以赋值给函数指针变量
		     */
		    void (*p)(char *) = f1;
		    p("hell world"); //使用函数指针直接调用函数
		}

### 函数返回指针
1.  函数也可以返回指针  
	返回值类型 *函数名（参数残表）  

		#include <stdio.h>
		#include <stdlib.h>
		
		int a = 10;
		int *f()
		{
		    /**
		     * 返回一个地址
		     * 注意不能返回一个局部变量的地址
		     */
		    return &a;
		}
		void main()
		{
		    printf("%d\n", *(f())); //取出
		}
2.代码  

		#include <stdio.h>
		#include <stdlib.h>
		
		char *mystrcpy(char *dst, char *src)
		{
		    if (dst == NULL || src == NULL) {
		        return NULL;
		    }
		    char *last = dst;
		    while ((*dst++ = *src++) != '\0') {
		
		    }
		    return last;
		}
		void main()
		{
		    char *src = "hell world";
		    char dst[20];
		    printf("%s\n", mystrcpy(dst, src));
		}

### 空指针
1. void *指针是一种特殊的指针，不指向任何类型的数据，如果需要用此地址指向某类型的数据，应先对地址进行类型转换
2. 空指针用于参数还有返回值，不明确指针类型的情况传递地址。  
	需要用到空类型的指针，要把它用于某种类型的指针，需要强制转换  

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int a = 1;
		    void *p;
		    p = &a; //空指针可以指向任务类型指针
		    printf("%d\n", *((int *)p)); //如果要取出指针指向的值，必须进行类型转换
		}

## 动态内存分配

### 定义
1. 静态分析本 int a[2][2],分配的内存在栈区，由系统回收。栈区大小有限制，分配过大内存会栈溢出，程序崩溃。
2.  动态分配，是指用户可以在程序运行期间根据需要申请或释放内存，大小也完全可控。动态分配不像数组内存那样需要预先分配空间，而是由系统根据程序需要动态分配，大小完全按照用户的要求来，当使用完毕后，用户还可释放所申请的动态内存，由系统回收，以备他用。动态分配的内存在堆区，大小只限制于机器内存大小。
3.  堆区的内存必须手动释放，不然就会造成内存泄露。
### malloc 和free 函数
1. 用户由此控制申请内存的大小，执行成功时，系统会为程序开辟一块大小为size个字节的区域，并将该区域的首地址返回，用户可利用该地址管理并使用该块内存，如果申请失败（比如内存大小不够用），返回空指针NULL  

		void *malloc( unsigned int size )

	用其返回值对其他类型指针赋值时，必须进行显式转换。

	free就是释放内存  

		free(p)
2. 代码  

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int *p = (int *)malloc(sizeof(int) * 10);
		    if (p == NULL) {
		        printf("malloc fail\n");
		        exit;
		    }
		    free(p); //注意释放了p后，p的值还在
		    p = NULL;  //良好的习惯 free后设置NULL
		}

### calloc
1. calloc函数是以目标对象为单位分配的，目标对象可以是数组，结构体。

		(类型 *)calloc(数量,sizeof(类型));
		返回NULL表示失败

### relloc
1.  relloc 如果可以拓展就拓展，否则就重新分配。拓展就是在原来地址后面增加内存。
不够的情况下，就回收原来的内存，并在回收之前分配一片内存，将原来的内容拷贝过来。然后收回原来的内存。

		(类型 *)relloc((void *)原指针, sizeof(类型) * 元素个数 )
		返回NULL表示失败
		
### 内存泄露
如果没有释放内存，但记录该块内存的指针消亡了或者是指针的值发生了改变，这块内存将永远得不到回收，造成了内存泄漏

### 说明
1. 动态分配的内存是连续的，所有我们可以使用数组的形式操作分配的内存。 但是在物理内存上可能不是连续的。

		#include <stdio.h>
		#include <stdlib.h>
		
		void main()
		{
		    int *p = (int *)malloc(sizeof(int) * 5);
		    for (int i = 0; i < 5; ++i) {
		        p[i] = i + 100; //数组方式操作内存。
		        printf("p[%d] = %d\n", i, p[i]);
		    }
		}